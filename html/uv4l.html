<html>
    <head>
        <title>UV4L Interface</title>

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <style>
table, tr, th, td {
    border-collapse: collapse;
}

button {
    width: 55px;
    height: 55px;
}
        </style>

        <!-- THREE.js libs:
             - three.js - core
             - DeviceOrientationControls - help mapping device to camera dir
             - StereoEffect - cardboard stuff
        -->
        <script src="js/third-party/threejs.r73/three.js"></script>
        <script src="js/third-party/threejs.r73/DeviceOrientationControls.js">
        </script>
        <script src="js/third-party/threejs.r73/StereoEffect.js">
        </script>
        <script src="js/third-party/threejs.r73/OculusRiftEffect.js">
        </script>

        <script src="js/utl.js"></script>

        <script src="js/orientation.js"></script>
        <script src="js/cardboard.js"></script>

        <script src='js/rdvp.js'></script>
        <script src='js/webrtc.js'></script>

        <script>


function PlaceStream(stream)
{
    domVideo = document.getElementById("videoRTC");

    domVideo.autoplay = true;
    domVideo.controls = true;
    domVideo.muted    = true;

    domVideo.src = URL.createObjectURL(stream);
}


function OnWebRTCStream(stream)
{
    console.log("OnWebRTCStream");
    PlaceStream(stream);
}

function OnWebRTCStreamEnd()
{
    document.getElementById("videoRTC").pause();
}

function OnClickConnectRTC()
{
    OnStartWebRTC(
        document.getElementById("clientIdWebRTC").value,
        document.getElementById("connectToIdWebRTC").value,
        document.getElementById("passwordWebRTC").value,
        function OnOpen() {
            document.getElementById("rtcStatus").style.backgroundColor = "green";
        }, function OnClose() {
            document.getElementById("rtcStatus").style.backgroundColor = "red";
        }
    );
}

function OnClickConnectServoX()
{
    OnStartServoX(
        document.getElementById("clientIdServoX").value,
        document.getElementById("connectToIdServoX").value,
        document.getElementById("passwordServoX").value,
        function OnOpen(ws) {
            document.getElementById("servoStatusX").style.backgroundColor = "green";
        }, function OnClose() {
            document.getElementById("servoStatusX").style.backgroundColor = "red";
        }
    );
}

function OnClickConnectServoY()
{
    OnStartServoY(
        document.getElementById("clientIdServoY").value,
        document.getElementById("connectToIdServoY").value,
        document.getElementById("passwordServoY").value,
        function OnOpen(ws) {
            document.getElementById("servoStatusY").style.backgroundColor = "green";
        }, function OnClose() {
            document.getElementById("servoStatusY").style.backgroundColor = "red";
        }
    );
}


var servoButtonsActive = false;
function ActivateServoButtons()
{
    servoButtonsActive = true;

    document.getElementById("buttonBorder").style.borderColor = "green";
}

function DeactivateServoButtons()
{
    servoButtonsActive = false;

    document.getElementById("buttonBorder").style.borderColor = "red";
}

var wsServoX = null;
function OnStartServoX(clientId, connectToId, password, cbOpen, cbClose)
{
    ws = RDVP_WebSocketThisHost("CC", clientId, password, connectToId);
    ws.onopen = function() {
        cbOpen();
    }

    ws.onclose = function() {
        cbClose();
    }

    wsServoX = ws;
}

var wsServoY = null;
function OnStartServoY(clientId, connectToId, password, cbOpen, cbClose)
{
    ws = RDVP_WebSocketThisHost("CC", clientId, password, connectToId);
    ws.onopen = function() {
        cbOpen();
    }

    ws.onclose = function() {
        cbClose();
    }

    wsServoY = ws;
}

var wsWebRTC = null;
var wrtcr = null;
function OnStartWebRTC(clientId, connectToId, password, cbOpen, cbClose)
{

    navigator.getUserMedia = navigator.getUserMedia ||
                             navigator.webkitGetUserMedia;

    var constraints = {
        audio: true,
        video: true
    };

//    navigator.getUserMedia(
//        constraints,
//        function OnSuccess(streamLocal) {
            ws = RDVP_WebSocketThisHost("CC", clientId, password, connectToId);

            streamLocal = null;

            ws.onopen = function() {
                wrtcr = WebRTC_Receiver(ws, streamLocal, {
                    OnStreamAdded: function(stream) {
                        OnWebRTCStream(stream);
                    },

                    OnStreamRemoved: function() {
                        OnWebRTCStreamEnd();

                        cbClose()
                    }
                });

                cbOpen();
            }

            wsWebRTC = ws;
//        }, function OnFailure(err) {
//            console.log("ERR: Could not get user media: " + err);
//        }
//    );
}

function OnClickDisconnectRTC()
{
    if (wsWebRTC) { wsWebRTC.close(); }

    OnWebRTCStreamEnd();
}

function OnClickDisconnectServoX()
{
    if (wsServoX) { wsServoX.close(); }
}

function OnClickDisconnectServoY()
{
    if (wsServoY) { wsServoY.close(); }
}



function GetRadioButtonVal(name)
{
    domElList = document.getElementsByName(name);

    for (var i = 0; i < domElList.length; ++i)
    {
        if (domElList[i].checked)
        {
            return domElList[i].value;
        }
    }
}


var pubLastX = 0;
function PublishToServoX(val, domId)
{
    val = val.toFixed(1);

    if (pubLastX)
    {
        if (Math.abs(val - pubLastX) >= 0.5)
        {
            wsServoX.send(val);

            pubLastX = val;
        }
        else
        {
            console.log("discarded " + val.toFixed(1) + ", same as before");
        }
    }
    else
    {
        pubLastX = val;
    }
}

var pubLastY = 0;
function PublishToServoY(val, domId)
{
    val = val.toFixed(1);

    if (pubLastY)
    {
        if (Math.abs(val - pubLastY) >= 0.5)
        {
            wsServoY.send(val);

            pubLastY = val;
        }
        else
        {
            console.log("discarded " + val.toFixed(1) + ", same as before");
        }
    }
    else
    {
        pubLastY = val;
    }
}


function ResetOrientationOffset()
{
    changeObjRef = changeObjNew;
}

var changeObjRef = null;
var changeObjNew = null;
function SetUpOrientationHandler()
{
    var oh = new OrientationHelper(function(changeObj) {
        changeObjNew = changeObj;

        var offset = 0;

        var firstTimeSinceReset = false;

        if (changeObjRef != null)
        {
            // map 360 degree val to -90 - 90
            offset = changeObjRef.degRotation - changeObj.degRotation;

            // limit range
            if (offset > 90)
            {
                offset = 90;
            }
            else if (offset < -90)
            {
                offset = -90;
            }
        }
        else
        {
            changeObjRef = changeObj;

            firstTimeSinceReset = true;
        }

        if (wsServoX &&
            !firstTimeSinceReset &&
            GetRadioButtonVal("ctlType") == "orientation")
        {
            PublishToServoX(offset, "orientationValSent");
        }

        if (wsServoY && GetRadioButtonVal("ctlType") == "orientation")
        {
            PublishToServoY(-changeObj.degUpDown, "orientationValSent");
        }

        document.getElementById("orientationVal").innerHTML =
            "raw: " + changeObj.degRotation + "<br/>" +
            "offset: " + offset;
    });
}

function OnRangeVal(val)
{
    if (wsServoX && GetRadioButtonVal("ctlType") == "range")
    {
        PublishToServoX(-val, "rangeValSent");
    }

    document.getElementById("rangeVal").innerHTML = -val;
}


function OnClickGetUserMedia()
{
    navigator.getUserMedia = navigator.getUserMedia ||
                             navigator.webkitGetUserMedia;

    navigator.getUserMedia(
        {
            audio: false,
            video: true
        },
        function OnSuccess(mediaStream) {
            PlaceStream(mediaStream);
        }, function OnFailure(err) {
            console.log("Couldn't get local media stream: " + err);
        }
    );
}



function OnLoad()
{
    var domVideo = document.getElementById("videoRTC");

    domVideo.onresize = function() {
        console.log("size changed: " + domVideo.videoWidth + "x" + domVideo.videoHeight);
    }

    SetUpOrientationHandler();
    Cardboard(domVideo);
}


        </script>
    </head>

    <body onload='OnLoad();'>


        <table border=1>
            <tr>
                <th>Ctl</th>
                <th>ID</th>
                <th>Service</th>
                <th>PW</th>
                <th>Action</th>
                <th>Status</th>
            </tr>
            <tr>
                <td>WebRTC</td>
                <td>
        <input id='clientIdWebRTC' value='CC_RTC' size='8'>
                </td>
                <td>
        <input id='connectToIdWebRTC' value='UV4L' size='8'>
                </td>
                <td>
        <input id='passwordWebRTC' value='' size='8'>
                </td>
                <td>
        <input type='button' value='connect' onclick='OnClickConnectRTC()'>
        <input type='button' value='disconnect' onclick='OnClickDisconnectRTC()'>
                </td>
                <td id='rtcStatus' style='background-color: red;'>
                </td>
            </tr>
            <tr>
                <td>ServoX</td>
                <td>
        <input id='clientIdServoX' value='CC_X' size='8'>
                </td>
                <td>
        <input id='connectToIdServoX' value='SERVO_X' size='8'>
                </td>
                <td>
        <input id='passwordServoX' value='' size='8'>
                </td>
                <td>
        <input type='button' value='connect' onclick='OnClickConnectServoX()'>
        <input type='button' value='disconnect' onclick='OnClickDisconnectServoX()'>
                </td>
                <td id='servoStatusX' style='background-color: red;'>
                </td>
            </tr>
            <tr>
                <td>ServoY</td>
                <td>
        <input id='clientIdServoY' value='CC_Y' size='8'>
                </td>
                <td>
        <input id='connectToIdServoY' value='SERVO_Y' size='8'>
                </td>
                <td>
        <input id='passwordServoY' value='' size='8'>
                </td>
                <td>
        <input type='button' value='connect' onclick='OnClickConnectServoY()'>
        <input type='button' value='disconnect' onclick='OnClickDisconnectServoY()'>
                </td>
                <td id='servoStatusY' style='background-color: red;'>
                </td>
            </tr>
        </table>

        <input type='button'
               value='getUserMedia'
               onclick='OnClickGetUserMedia()'>

        <br/>

        <style>
/*

I've seen the streaming video at resolutions:
- 640x480 (WebRTC, getUserMedia)
- 480x360 (WebRTC)
- 320x240 (WebRTC)

And it changes during playback from WebRTC streams.

}

 */

#videoRTC {
    width: 320px;
    height: 240px;
}

        </style>
        <div id='remoteStreamContainer'>
            <video id='videoRTC'></video>
        </div>

        <br/>

        Camera Control
        <table border=1>
            <tr>
                <th>use</th>
                <th>input</th>
                <th>value</th>
                <th>sent</th>
            </tr>
            <tr>
                <td><input type='radio' name='ctlType' value='orientation'></input></td>
                <td>
                orientation
                <button onclick='ResetOrientationOffset();'>set origin</button>
                </td>
                <td><div id='orientationVal'>0</div></td>
                <td><div id='orientationValSent'>0</div></td>
            </tr>
            <tr>
                <td><input type='radio' name='ctlType' value='range' checked></input></td>
                <td>
                    <input type='range' min='-90' max='90' step='1' value='0'
                           oninput='OnRangeVal(this.value);'
                           ></input>
                </td>
                <td><div id='rangeVal'>0</div></td>
                <td><div id='rangeValSent'>0</div></td>
            </tr>
        </table>

        <br/>
        <br/>

        Cardboard View (latest 3)<br/>
<style>

#restrainer {
    width: 480;
    height: 240;
}

#cardboardContainer {
    height: 100%;
    width: 100%;
}

</style>
        <div id='restrainer'>
            <div id='cardboardContainer'>
            </div>
        </div>

        <table>
            <tr>
                <td>
                camera.aspect
                </td>
                <td>
        <input type='range' min='0.5' max='1.5' step='0.1' value='1'
               oninput='
                   camera.aspect = this.value;
                   parentNode.nextElementSibling.innerHTML = this.value;
               '
               ></input>
                </td>
                <td>
                1
                </td>
            </tr>
            <tr>
                <td>
                canvas.height
                </td>
                <td>
        <input type='range' min='512' max='1024' step='512' value='1024'
               oninput='
                   canvas.height= this.value;
                   parentNode.nextElementSibling.innerHTML = this.value;
               '
               ></input>
                </td>
                <td>
                1024
                </td>
            </tr>
            <tr>
                <td>
                canvas.width
                </td>
                <td>
        <input type='range' min='512' max='1024' step='512' value='1024'
               oninput='
                   canvas.width= this.value;
                   parentNode.nextElementSibling.innerHTML = this.value;
               '
               ></input>
                </td>
                <td>
                1024
                </td>
            </tr>
            <tr>
                <td>
                cameraMesh.position.z
                </td>
                <td>
        <input type='range' min='100' max='1200' step='100' value='500'
               oninput='
                   cameraMesh.position.z=-this.value;
                   parentNode.nextElementSibling.innerHTML = this.value;
               '
               ></input>
                </td>
                <td>
                500
                </td>
            </tr>
            <tr>
                <td>
                cameraMesh.position.y
                </td>
                <td>
        <input type='range' min='10' max='100' step='5' value='75'
               oninput='
                   cameraMesh.position.y=this.value;
                   parentNode.nextElementSibling.innerHTML = this.value;
               '
               ></input>
                </td>
                <td>
                75
                </td>
            </tr>
        </table>


        <br/>
        <br/>
        <br/>
        <br/>

    </body>
</html>









